var documenterSearchIndex = {"docs":
[{"location":"internal/","page":"Internal","title":"Internal","text":"Modules = [FieldTracer]","category":"page"},{"location":"internal/#FieldTracer.DoBreak-Union{Tuple{T}, NTuple{4,T}} where T<:Integer","page":"Internal","title":"FieldTracer.DoBreak","text":"DoBreak(iloc, jloc, iSize, jSize)\n\nCheck to see if we should break out of an integration.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.Euler!-NTuple{12,Any}","page":"Internal","title":"FieldTracer.Euler!","text":"Euler!(iSize,jSize, maxstep, ds, xstart,ystart, xGrid,yGrid, ux,uy, x,y)\n\nSimple 2D tracing using Euler's method. Super fast but not super accurate.\n\nArguments\n\niSize::Int,jSize::Int: grid size.\nmaxstep::Int: max steps.\nds::Float64: step size.\nxstart::Float64, ystart::Float64: starting location.\nxGrid::Vector{Float64},yGrid::Vector{Float64}: actual coord system.\nux::Array{Float64,2},uy::Array{Float64,2}: field to trace through.\nx::Vector{Float64},y::Vector{Float64}: x, y of result stream.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.Euler!-NTuple{17,Any}","page":"Internal","title":"FieldTracer.Euler!","text":"Euler!(iSize, jSize, kSize, maxstep, ds, xstart, ystart, zstart,\n  xGrid, yGrid, zGrid, ux, uy, uz, x, y, z)\n\nSimple 3D tracing using Euler's method.\n\nArguments\n\niSize::Int,jSize::Int,kSize::Int: grid size.\nmaxstep::Int: max steps.\nds::Float64: step size.\nxstart::Float64, ystart::Float64, zstart::Float64: starting location.\nxGrid::Array{Float64,2},yGrid::Array{Float64,2},zGrid::Array{Float64,2}: actual coord system.\nux::Array{Float64,2},uy::Array{Float64,2},uz::Array{Float64,2}: field to trace through.\nx::Vector{Float64},y::Vector{Float64},z::Vector{Float64}: x, y, z of result stream.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.RK4!-NTuple{12,Any}","page":"Internal","title":"FieldTracer.RK4!","text":"RK4!(iSize,jSize, maxstep, ds, xstart,ystart, xGrid,yGrid, ux,uy, x,y)\n\nFast and reasonably accurate 2D tracing with 4th order Runge-Kutta method and constant step size ds.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.RK4!-NTuple{17,Any}","page":"Internal","title":"FieldTracer.RK4!","text":"RK4!(iSize,jSize,kSize, maxstep, ds, xstart,ystart,zstart,\n  xGrid,yGrid,zGrid, ux,uy,uz, x,y,z)\n\nFast and reasonably accurate 3D tracing with 4th order Runge-Kutta method and constant step size ds.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.bilin_reg-NTuple{6,Any}","page":"Internal","title":"FieldTracer.bilin_reg","text":"bilin_reg(x, y, Q00, Q01, Q10, Q11)\n\nBilinear interpolation for x1,y1=(0,0) and x2,y2=(1,1) Q's are surrounding points such that Q00 = F[0,0], Q10 = F[1,0], etc.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.grid_interp!-NTuple{7,Any}","page":"Internal","title":"FieldTracer.grid_interp!","text":"grid_interp!(x, y, z, field, ix, iy, iz, xsize, ysize)\n\nInterpolate a value at (x,y,z) in a field. ix,iy and iz are indexes for x,y and z locations (0-based). xsize and ysize are the sizes of field in X and Y.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.grid_interp!-Tuple{Any,Any,Array,Any,Any}","page":"Internal","title":"FieldTracer.grid_interp!","text":"grid_interp!(x, y, field, ix, iy, xsize)\n\nInterpolate a value at (x,y) in a field. ix and iy are indexes for x,y locations (0-based). xsize is the size of field in X.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.normalize_field-Union{Tuple{T}, Tuple{T,T,Any,Any,Any,Any}} where T<:Integer","page":"Internal","title":"FieldTracer.normalize_field","text":"Create unit vectors of field.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.normalize_field-Union{Tuple{T}, Tuple{T,T,T,Any,Any,Any,Any,Any,Any}} where T<:Integer","page":"Internal","title":"FieldTracer.normalize_field","text":"Create unit vectors of field in normalized coordinates.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.select_seeds-Tuple{Any,Any}","page":"Internal","title":"FieldTracer.select_seeds","text":" select_seeds(x, y, nSeed=100)\n\nGenerate nSeed seeding points randomly in the grid range. If you specify nSeed, use the keyword input, otherwise it will be overloaded by the 3D version seed generation.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.trace2d_eul-NTuple{6,Any}","page":"Internal","title":"FieldTracer.trace2d_eul","text":" trace2d_eul(fieldx, fieldy, xstart, ystart, gridx, gridy;\n\t maxstep=20000, ds=0.01, gridType=\"meshgrid\", direction=\"both\")\n\nGiven a 2D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Euler's method. While this is faster than rk4, it is less accurate. Only valid for regular grid with coordinates gridx, gridy. If gridx and gridy are not given, assume that xstart and ystart are normalized coordinates (e.g. position in terms of array indices.)??? The field can be in both meshgrid (default) or ndgrid format. Supporting direction for {\"both\",\"forward\",\"backward\"}.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.trace2d_rk4-NTuple{6,Any}","page":"Internal","title":"FieldTracer.trace2d_rk4","text":" trace2d_rk4(fieldx, fieldy, xstart, ystart, gridx, gridy;\n\t maxstep=20000, ds=0.01, gridType=\"meshgrid\", direction=\"both\")\n\nGiven a 2D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Runge Kutta 4. Slower than Euler, but more accurate. The higher accuracy allows for larger step sizes ds.  Only valid for regular grid with coordinates gridx, gridy. If gridx and gridy are not given, assume that xstart and ystart are normalized coordinates (e.g., position in terms of array indices.???) The field can be in both meshgrid (default) or ndgrid format. Supporting direction for {\"both\",\"forward\",\"backward\"}.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.trace3d_eul-NTuple{9,Any}","page":"Internal","title":"FieldTracer.trace3d_eul","text":" trace3d_eul(fieldx, fieldy, fieldz, xstart, ystart, zstart, gridx, gridy,\n   gridz; maxstep=20000, ds=0.01)\n\nGiven a 3D vector field, trace a streamline from a given point to the edge of the vector field. The field is integrated using Euler's method. Only valid for regular grid with coordinates gridx, gridy, gridz. The field can be in both meshgrid or ndgrid (default) format.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FieldTracer.trilin_reg-NTuple{4,Any}","page":"Internal","title":"FieldTracer.trilin_reg","text":"trilin_reg(x, y, z, Q)\n\nTrilinear interpolation for x1,y1,z1=(0,0,0) and x2,y2,z2=(1,1,1) Q's are surrounding points such that Q000 = F[0,0,0], Q100 = F[1,0,0], etc.\n\n\n\n\n\n","category":"method"},{"location":"log/#Log","page":"Log","title":"Log","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"Original version in C from LANL. Reimplement in Julia. Calling the native functions in Julia is about 5 times faster than calling the dynmic C library. Some of the tests originates from SpacePy. Bug fixed for nonuniform dx, dy and dz grid.","category":"page"},{"location":"log/#Limitations","page":"Log","title":"Limitations","text":"","category":"section"},{"location":"log/","page":"Log","title":"Log","text":"Currently most tracing functions assume regular grid, meaning that the size of each cell is not changing. However, the whole grid information is passed all the way down to the kernel functions, which may be a waste of memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FieldTracer","category":"page"},{"location":"#FieldTracer","page":"Home","title":"FieldTracer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vector field tracing on common types of meshes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supports 2nd order and 4th order field line tracing on","category":"page"},{"location":"","page":"Home","title":"Home","text":"2D/3D regular Cartesian mesh\n2D unstructured quadrilateral mesh\n2D unstructured triangular mesh","category":"page"}]
}
